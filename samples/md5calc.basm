; Implementation of an MD5 checksum computation with the ByteMachine.
; It is pretty cumbersome to work with 32 bit integers, but it can be 
; done even with this simple instruction set and without a carry flag.

; ----------- RAM LAYOUT ----------------
	A0 = 0         ; 32 bit
  	B0 = 4         ; 32 bit
	C0 = 8         ; 32 bit
	D0 = 12        ; 32 bit	   	 
	M  = 16        ; 16x32 bit blocks of message data
	BITLENGTH = 80 ; 32 bit
	A = 84		   ; 32 bit
	B = 88         ; 32 bit
	C = 92         ; 32 bit
	D = 96         ; 32 bit
	K = 100        ; 32 bit
	F = 104        ; 32 bit
	CONSTANT8 = 108 ; 32 bit (constant value 8)
	LENGTH = 112   ;  8 bit  (length currently collect in block)
; -------------MD5 EXAMPLE USAGE -------------
MAIN:
	JSR MD5INIT	
	JSR APPENDEXAMPLETEXT	
	JSR MD5FINISH
	JSR MD5PRINT
OVER:
	JMP OVER

APPENDEXAMPLETEXT:
	>PUSH 0      
	! i 
LOOPEXAMPLETEXT:
    >GET i
    -LOADX EXAMPLETEXT 
	->DUP
    -<JNZ HAVELETTER
	<POP	
	RETURN 0
HAVELETTER:	
    <JSR MD5APPEND
	INC
    JMP LOOPEXAMPLETEXT

	
; ---------- EXAMPLE TEXT
EXAMPLETEXT:
	DATA "Mary had a little lamb, His fleece was white as snow, And everywhere that Mary went, The lamb was sure to go." 
	DATA 0
	
	
; ---------- CONSTANT DATA --------------
STARTVALUES:	DATA32 0x67452301
                DATA32 0xEFCDAB89
             	DATA32 0x98BADCFE
                DATA32 0x10325476
s : DATA 7 12 17 22  7 12 17 22  7 12 17 22  7 12 17 22
    DATA 5  9 14 20  5  9 14 20  5  9 14 20  5  9 14 20
    DATA 4 11 16 23  4 11 16 23  4 11 16 23  4 11 16 23
    DATA 6 10 15 21  6 10 15 21  6 10 15 21  6 10 15 21
k : DATA32 0xd76aa478 0xe8c7b756 0x242070db 0xc1bdceee
	DATA32 0xf57c0faf 0x4787c62a 0xa8304613 0xfd469501
	DATA32 0x698098d8 0x8b44f7af 0xffff5bb1 0x895cd7be
    DATA32 0x6b901122 0xfd987193 0xa679438e 0x49b40821
    DATA32 0xf61e2562 0xc040b340 0x265e5a51 0xe9b6c7aa
    DATA32 0xd62f105d 0x02441453 0xd8a1e681 0xe7d3fbc8
    DATA32 0x21e1cde6 0xc33707d6 0xf4d50d87 0x455a14ed
    DATA32 0xa9e3e905 0xfcefa3f8 0x676f02d9 0x8d2a4c8a
    DATA32 0xfffa3942 0x8771f681 0x6d9d6122 0xfde5380c
    DATA32 0xa4beea44 0x4bdecfa9 0xf6bb4b60 0xbebfbc70
    DATA32 0x289b7ec6 0xeaa127fa 0xd4ef3085 0x04881d05
    DATA32 0xd9d4d039 0xe6db99e5 0x1fa27cf8 0xc4ac5665
    DATA32 0xf4292244 0x432aff97 0xab9423a7 0xfc93a039
    DATA32 0x655b59c3 0x8f0ccc92 0xffeff47d 0x85845dd1
    DATA32 0x6fa87e4f 0xfe2ce6e0 0xa3014314 0x4e0811a1
    DATA32 0xf7537e82 0xbd3af235 0x2ad7d2bb 0xeb86d391 
			
			
; -------------- MD5 COMPUTATION -------------

MD5INIT:
	>PUSH A0
MD5INITLOOP:	
	->DUP
	--LOADX STARTVALUES-A0
	-<STORE
	-INC
	->PUSH A0+16
	--LT
	-<JNZ MD5INITLOOP
	<POP	
	>PUSH BITLENGTH
	<JSR CLEAR32	
	>PUSH LENGTH
	->PUSH 0
	-<STORE	
	<POP
	>PUSH CONSTANT8
	<JSR CLEAR32
	>PUSH CONSTANT8
	->PUSH 8
	-<STORE	
	<POP
	RET
	
MD5APPEND:   ;  DATABYTE  -> -
	->PUSH 1
	<<JSR MD5APPENDCHECKCOUNTER
	RET

MD5FINISH:
	>PUSH 128
	->PUSH 0
	<<JSR MD5APPENDCHECKCOUNTER
MD5FINISHLOOP:
	>PUSH LENGTH
	-LOAD
	->PUSH 56
	-<XOR
	<JZ MD5FINISHLOOPEND
	>PUSH 0
	->PUSH 0
	<<JSR MD5APPENDCHECKCOUNTER
	JMP MD5FINISHLOOP
MD5FINISHLOOPEND:	
	>PUSH BITLENGTH
	->PUSH M+56
	<<JSR COPY32
	>PUSH M+60
	<JSR CLEAR32
	JSR MD5COMPUTEBLOCK
	RET
	
MD5PRINT:
	>PUSH A0
	<JSR PRINT32
	>PUSH B0
	<JSR PRINT32
	>PUSH C0
	<JSR PRINT32
	>PUSH D0
	<JSR PRINT32
	<JSR PRINTNEWLINE
	RET

MD5APPENDCHECKCOUNTER:  ;  DATABYTE INCREASECOUNTER -> -
	! databyte
    <JZ MD5NOCOUNTERINCREASE
	>PUSH CONSTANT8
	->PUSH BITLENGTH
	<<JSR ADD32		
MD5NOCOUNTERINCREASE:	
	>PUSH LENGTH
	-LOAD	
	->PUSH M
	-<ADD
	->GET databyte
	-<STORE
	<POP
	>PUSH LENGTH
	->LOAD
	--INC
	-<STORE
	-LOAD
	->PUSH 64
	-<XOR
	<JNZ MD5APPENDDONE
	JSR MD5COMPUTEBLOCK
	>PUSH LENGTH
	->PUSH 0
	-<STORE
	<POP
MD5APPENDDONE:	
	RETURN 0

MD5COMPUTEBLOCK:
	>PUSH 0
	! i
	>PUSH A0
	->PUSH A
	<<JSR COPY32
	>PUSH B0
	->PUSH B
	<<JSR COPY32
	>PUSH C0
	->PUSH C
	<<JSR COPY32
	>PUSH D0
	->PUSH D
	<<JSR COPY32
COMPUTEBLOCKLOOP0:
	>PUSH C
	->PUSH F
	<<JSR COPY32
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>PUSH B
	->PUSH F
	<<JSR AND32
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	<<JSR MD5ROUND
	INC
	>PUSH 16
	-LT
	<JNZ COMPUTEBLOCKLOOP0
COMPUTEBLOCKLOOP16:
	>PUSH B
	->PUSH F
	<<JSR COPY32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>PUSH D
	->PUSH F
	<<JSR AND32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	-->PUSH 2
	--<LSL
	-->GET i
	--<ADD
	--INC
	-->PUSH 15
	--<AND	
	<<JSR MD5ROUND
	INC
	>PUSH 32
	-LT
	<JNZ COMPUTEBLOCKLOOP16
COMPUTEBLOCKLOOP32:
	>PUSH B
	->PUSH F
	<<JSR COPY32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	-->GET i
	--<ADD
	-->GET i
	--<ADD
	-->PUSH 5
	--<ADD
	-->PUSH 15
	--<AND
	<<JSR MD5ROUND
	INC
	>PUSH 48
	-LT
	<JNZ COMPUTEBLOCKLOOP32
COMPUTEBLOCKLOOP48:
	>PUSH F
	->PUSH 255
	-->PUSH 4
	<<<JSR FILL
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>PUSH B
	->PUSH F
	<<JSR OR32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	-->PUSH 2
	--<LSL
	-->GET i	
	--<ADD
	-->GET i
	--<ADD
	-->GET i	
	--<ADD
	-->PUSH 15
	--<AND
	<<JSR MD5ROUND
	INC
	>PUSH 64
	-LT
	<JNZ COMPUTEBLOCKLOOP48		
	>PUSH A
	->PUSH A0
	<<JSR ADD32
	>PUSH B
	->PUSH B0
	<<JSR ADD32
	>PUSH C
	->PUSH C0
	<<JSR ADD32
	>PUSH D
	->PUSH D0
	<<JSR ADD32	
	RETURN 0

MD5ROUND:   ;   i g  -> 
	! i g 
	>GET i
	->PUSH 2
	-<LSL
	! i g i4
	; loading value of k[i] into K
	>PUSH K
	->GET i4
	--LOADX k
	-<STORE
	-INC
	->GET i4
	--LOADX k+1
	-<STORE
	-INC
	->GET i4
	--LOADX k+2
	-<STORE
	-INC
	->GET i4
	--LOADX k+3
	-<STORE
	<POP
	>PUSH A
	->PUSH F
	<<JSR ADD32
	>PUSH K
	->PUSH F
	<<JSR ADD32
	>PUSH M
	->GET g
	-->PUSH 2
	--<LSL
	-<ADD
	->PUSH F
	<<JSR ADD32
	>GET i
	-LOADX s
	->PUSH F
	<<JSR ROL32
	>PUSH D
	->PUSH A
	<<JSR COPY32
	>PUSH C
	->PUSH D
	<<JSR COPY32
	>PUSH B
	->PUSH C
	<<JSR COPY32
	>PUSH F
	->PUSH B
	<<JSR ADD32
	RETURN 0
	
; ---------- COMPUTATION AND MOVEMENT PRIMITIVES ---------

CLEAR32:	  ; ADDRESS -> -
	->PUSH 0
	-->PUSH 4
	<<<JSR FILL
	RET
	
COPY32:   ; sourceaddr targetaddr -> -
	>PUSH 0
	! sourceaddr targetaddr index
COPY32LOOP:	
	>GET targetaddr
	->GET index
	-<ADD
	->GET sourceaddr
	-->GET index
	--<ADD
	--LOAD
	-<STORE
	<POP
	INC
	>PUSH 4
	-LT
	<JNZ COPY32LOOP
	RETURN 0
		
AND32:	; sourceaddr targetaddr  -> -
	>PUSH 0
	! sourceaddr targetaddr index
AND32LOOP:	
	>GET targetaddr
	->GET index
	-<ADD
	->LOAD
	-->GET sourceaddr
	--->GET index
	---<ADD
	---LOAD
	--<AND
	-<STORE
	<POP
	INC
	>PUSH 4
	-LT
	<JNZ AND32LOOP
	RETURN 0

OR32:	; sourceaddr targetaddr  -> -
	>PUSH 0
	! sourceaddr targetaddr index
OR32LOOP:	
	>GET targetaddr
	->GET index
	-<ADD
	->LOAD
	-->GET sourceaddr
	--->GET index
	---<ADD
	---LOAD
	--<OR
	-<STORE
	<POP
	INC
	>PUSH 4
	-LT
	<JNZ OR32LOOP
	RETURN 0

XOR32:	; sourceaddr targetaddr  -> -
	>PUSH 0
	! sourceaddr targetaddr index
XOR32LOOP:	
	>GET targetaddr
	->GET index
	-<ADD
	->LOAD
	-->GET sourceaddr
	--->GET index
	---<ADD
	---LOAD
	--<XOR
	-<STORE
	<POP
	INC
	>PUSH 4
	-LT
	<JNZ XOR32LOOP
	RETURN 0
	
ADD32:  ; sourceaddr targetaddr  -> -
	>PUSH 0
	->PUSH 0
	! sourceaddr targetaddr index carry
ADD32LOOP:		
	>GET sourceaddr
	->GET index
	-<ADD
	-LOAD
	->GET targetaddr
	-->GET index
	--<ADD
	--LOAD
	-<JSR ADDWITHCARRY
	->GET targetaddr
	-->GET index
	--<ADD
	-->OVER
	--<STORE
	-<POP
	<POP
	>GET index
	-INC
	-SET index
	->PUSH 4
	-<LT
	<JNZ ADD32LOOP
	RETURN 0

ADDWITHCARRY:   ; carry a b  ->  carry sum
	! carry a/sum b
	; detect if a+b itself would produce an overflow
	>GET a
	->GET b
	-->PUSH 255
	--<XOR
	-<GT
	<JNZ APLUSBOVERFLOWS
	!  carry/carry sum   ; use different stack layout to pop beyond previous limit
	<ADD       ; sum up a and b - no overflow can arise
	>GET carry  ; check if carry is comming in
	<JZ ADDWITHCARRYISFINISHED   ; when no carry comes in, no overflow can happen (and carry is already cleared)	
	INC       ; carry did come in, so increase the sum 	
	>GET sum  ; when after increasing, the value is 0, there was an overflow (and carry is already set)
	<JZ ADDWITHCARRYISFINISHED
	>PUSH 0
	<SET carry   ; output carry must be cleared
	RETURN 2
APLUSBOVERFLOWS:
	!  carry sum   ; use different stack layout to pop beyond previous limit
	<ADD		; sum up a and b, ignoring overflow
	ADD         ; add input carry to total value  (can not cause more total overflow)
	>PUSH 1
	<SET carry   ; output carry must be set
ADDWITHCARRYISFINISHED:
	RETURN 2

	
ROL32:      ;  distance address  -> -
	! distance address
	>GET distance
	<JZ ROL32DONE
	>PUSH 0
	->GET address
	--JSR ROLWITHCARRY
	--INC
	--JSR ROLWITHCARRY
	--INC
	--JSR ROLWITHCARRY
	--INC
	--JSR ROLWITHCARRY
	-<POP
	->GET address
	--LOAD
	-<OR
	->GET address
	-->OVER
	--<STORE
	-<POP
	<POP
	>GET distance
	-DEC
	<SET distance
	JMP ROL32
ROL32DONE:	
	RETURN 0
	
ROLWITHCARRY:	  ; carry_in address -> carry_out address
	! carry address
	>LOAD
	->DUP
	-->PUSH 1
	--<LSL
	-->GET carry
	--<OR
	-->GET address
	--->OVER
	---<STORE
	--<POP
	-<POP
	->PUSH 7
	-<LSR
	<SET carry
	RETURN 2

FILL:	  ; ADDRESS DATA LENGTH -> -
	! address data length
FILLLOOP:
	DEC
	>GET address
	-ADD
	->GET data
	-<STORE
	<POP
	>GET length
	<JNZ FILLLOOP
	RETURN 0

; ---------- DATA OUTPUT FUNCTIONS ------------

PRINTNEWLINE:
	>PUSH 10
	->PUSH 0
	-<WRITE
	<POP
	RET
	
PRINT32:       ;     ADDRESS -> -
	->PUSH 4
	<<JSR PRINTHEXBUFFER
	RET
	
PRINTHEXBUFFER:  ;  ADDRESS LENGTH -> -	
	! address length
	>GET length
	<JZ PRINTHEXBUFFEREND
PRINTHEXBUFFERLOOP:	
	>GET address
	->LOAD
	-<JSR PRINTHEXBYTE
	-INC
	<SET address
	DEC
	>GET length
	<JNZ PRINTHEXBUFFERLOOP
PRINTHEXBUFFEREND:	
	RETURN 0	

PRINTHEXBYTE:   ;  VALUE  ->  -
	->PUSH 4
	--LSR
	-<JSR PRINTHEXDIGIT
	->PUSH 15
	-<AND
	<JSR PRINTHEXDIGIT
	RET
	
PRINTHEXDIGIT:  ;  VALUE  ->  -
	-LOADX HEXDIGITS
	->PUSH 0
	-<WRITE
	<POP
	RET
	
HEXDIGITS:
	DATA "0123456789ABCDEF"
	
