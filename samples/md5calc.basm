; Implementation of an MD5 checksum computation with the ByteMachine.
; It is pretty cumbersome to work with 32 bit integers, but it can be 
; done even with this simple instruction set and without a carry flag.
; So this implementation works as a proof that such complex operations
; can indeed be implemented with this instruction set.
; The example output should be: 0f8b13e30bf9c0195964561732be6cc6

; ----------- RAM INITIALIZATION AND STARTUP -------------
A0 = 0         ; 32 bit
	DATA32 0
B0 = 4         ; 32 bit
	DATA32 0
C0 = 8         ; 32 bit
	DATA32 0
D0 = 12        ; 32 bit	   	 
	DATA32 0
M  = 16        ; 16x32 bit block of message data
	DATA32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
LENGTH = 80   ;  8 bit, data currently collected in M
	DATA 0
BITLENGTH = 81 ; 32 bit, total length of message in bits
	DATA32 0
A = 85		   ; 32 bit, temporary
	DATA32 0
B = 89         ; 32 bit, temporary
	DATA32 0
C = 93         ; 32 bit, temporary
	DATA32 0
D = 97         ; 32 bit, temporary
	DATA32 0
K = 101        ; 32 bit, temporary
	DATA32 0
F = 105        ; 32 bit, temporary
	DATA32 0
	
	CALL MAIN
	HALT
	
; ------------------- MD5 EXAMPLE USAGE -------------
MAIN:
; stack-in: (ret1,ret2)
--CALL MD5INIT	
--CALL APPENDEXAMPLETEXT	
--CALL MD5FINISH
--CALL MD5PRINT
<<RETURN

APPENDEXAMPLETEXT:
; stack-in: (ret1,ret2)
-->>>>>>>>>>>>>DATA 12 "Mary had a l"
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 "ittle lamb, "
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 "His fleece w"
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 "as white as "
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 "snow, And ev"
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 "erywhere tha"
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 "t Mary went,"
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 " The lamb wa"
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 12 "s sure to go"
--<<<<<<<<<<<<<CALL APPENDBYTES
-->>>>>>>>>>>>>DATA 1 ".xxxxxxxxxxxx"
--<<<<<<<<<<<<<CALL APPENDBYTES
<<RETURN

APPENDBYTES:
; stack-in: num b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 (ret1,ret2)
--------------->ADR !1
---------------->GET !0
---------------<<CALL MD5APPEND
<<<<<<<<<<<<<<<RETURN


; ---------- CONSTANT DATA --------------
				
s : DATA 7 12 17 22  7 12 17 22  7 12 17 22  7 12 17 22
    DATA 5  9 14 20  5  9 14 20  5  9 14 20  5  9 14 20
    DATA 4 11 16 23  4 11 16 23  4 11 16 23  4 11 16 23
    DATA 6 10 15 21  6 10 15 21  6 10 15 21  6 10 15 21
	
k : DATA32 0xd76aa478 0xe8c7b756 0x242070db 0xc1bdceee
	DATA32 0xf57c0faf 0x4787c62a 0xa8304613 0xfd469501
	DATA32 0x698098d8 0x8b44f7af 0xffff5bb1 0x895cd7be
    DATA32 0x6b901122 0xfd987193 0xa679438e 0x49b40821
    DATA32 0xf61e2562 0xc040b340 0x265e5a51 0xe9b6c7aa
    DATA32 0xd62f105d 0x02441453 0xd8a1e681 0xe7d3fbc8
    DATA32 0x21e1cde6 0xc33707d6 0xf4d50d87 0x455a14ed
    DATA32 0xa9e3e905 0xfcefa3f8 0x676f02d9 0x8d2a4c8a
    DATA32 0xfffa3942 0x8771f681 0x6d9d6122 0xfde5380c
    DATA32 0xa4beea44 0x4bdecfa9 0xf6bb4b60 0xbebfbc70
    DATA32 0x289b7ec6 0xeaa127fa 0xd4ef3085 0x04881d05
    DATA32 0xd9d4d039 0xe6db99e5 0x1fa27cf8 0xc4ac5665
    DATA32 0xf4292244 0x432aff97 0xab9423a7 0xfc93a039
    DATA32 0x655b59c3 0x8f0ccc92 0xffeff47d 0x85845dd1
    DATA32 0x6fa87e4f 0xfe2ce6e0 0xa3014314 0x4e0811a1
    DATA32 0xf7537e82 0xbd3af235 0x2ad7d2bb 0xeb86d391 
			
			
; -------------- MD5 COMPUTATION -------------

MD5INIT:
; stack-in: (ret1,ret2)
-->>>>DATA32 0x67452301
------>DATA A0
--<<<<<CALL INIT32
-->>>>DATA32 0x0xEFCDAB89
------>DATA B0
--<<<<<CALL INIT32
-->>>>DATA32 0x98BADCFE
------>DATA C0
--<<<<<CALL INIT32
-->>>>DATA32 0x10325476
------>DATA D0
--<<<<<CALL INIT32
-->>>>DATA32 0
------>DATA BITLENGTH
--<<<<<CALL INIT32
-->DATA 0
--->DATA LENGTH
---<STO
--<OP POP
<<RETURN

MD5APPEND: 
; stack-in: address, length, (ret1,ret2)
---->GET !1
----<JNZ MD5APPENDCONTINUE
<<<<RETURN
MD5APPENDCONTINUE:
---->GET !0
-----LOD
----->DATA 1
----<<CALL MD5APPENDCHECKCOUNTER
---->GET !0
----->DATA 1
-----<OP ADD
----<SET !0
---->GET !1
----->DATA 1
-----<OP SUB
----<SET !1
----JMP MD5APPEND

MD5FINISH:
; stack-in: (ret1,ret2)
-->>DATA 128 0
--<<CALL MD5APPENDCHECKCOUNTER
MD5FINISHLOOP:
-->DATA LENGTH
---LOD 0
--->PUSH 56
---<XOR
--<JZ MD5FINISHLOOPEND
-->>DATA 0 0
--<<CALL MD5APPENDCHECKCOUNTER
--JMP MD5FINISHLOOP
MD5FINISHLOOPEND:	
-->>DATA BITLENGTH M+56
--<<CALL COPY32
-->>>>DATA32 0
------>DATA M+60
--<<<<<CALL INIT32
--JSR MD5COMPUTEBLOCK
<<RETURN
	
MD5PRINT:
; stack-in: (ret1,ret2)
-->DATA A0
--<CALL PRINT32
-->DATA B0
--<CALL PRINT32
-->DATA C0
--<CALL PRINT32
-->DATA D0
--<CALL PRINT32
--CALL PRINTNEWLINE
<<RETURN

MD5APPENDCHECKCOUNTER:  ;  DATABYTE INCREASECOUNTER -> -
	! databyte
    <JZ MD5NOCOUNTERINCREASE
	>PUSH CONSTANT8
	->PUSH BITLENGTH
	<<JSR ADD32		
MD5NOCOUNTERINCREASE:	
	>PUSH LENGTH
	->LOAD	0
	-<SQUEEZE
	->PUSH M
	-<ADD
	->GET databyte
	-<STORE 0
	<POP
	>PUSH LENGTH
	->LOAD 0
	-->PUSH 1
	--<ADD
	-<STORE 0
	->LOAD 0
	-<SQUEEZE
	->PUSH 64
	-<XOR
	<JNZ MD5APPENDDONE
	JSR MD5COMPUTEBLOCK
	>PUSH LENGTH
	->PUSH 0
	-<STORE 0
	<POP
MD5APPENDDONE:	
	RETURN 0

MD5COMPUTEBLOCK:
	>PUSH 0
	! i
	>PUSH A0
	->PUSH A
	<<JSR COPY32
	>PUSH B0
	->PUSH B
	<<JSR COPY32
	>PUSH C0
	->PUSH C
	<<JSR COPY32
	>PUSH D0
	->PUSH D
	<<JSR COPY32
COMPUTEBLOCKLOOP0:
	>PUSH C
	->PUSH F
	<<JSR COPY32
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>PUSH B
	->PUSH F
	<<JSR AND32
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	<<JSR MD5ROUND
	>PUSH 1
	<ADD
	>PUSH 16
	->LT
	-<SQUEEZE
	<JNZ COMPUTEBLOCKLOOP0
COMPUTEBLOCKLOOP16:
	>PUSH B
	->PUSH F
	<<JSR COPY32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>PUSH D
	->PUSH F
	<<JSR AND32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	-->PUSH 2
	--<LSL
	-->GET i
	--<ADD
	-->PUSH 1
	--<ADD
	-->PUSH 15
	--<AND	
	<<JSR MD5ROUND
	>PUSH 1
	<ADD
	>PUSH 32
	->LT
	-<SQUEEZE
	<JNZ COMPUTEBLOCKLOOP16
COMPUTEBLOCKLOOP32:
	>PUSH B
	->PUSH F
	<<JSR COPY32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	-->GET i
	--<ADD
	-->GET i
	--<ADD
	-->PUSH 5
	--<ADD
	-->PUSH 15
	--<AND
	<<JSR MD5ROUND
	>PUSH 1
	<ADD
	>PUSH 48
	->LT
	-<SQUEEZE
	<JNZ COMPUTEBLOCKLOOP32
COMPUTEBLOCKLOOP48:
---->>>>DATA32 0xffffffff
-------->DATA F
	<CALL COPY32
	>PUSH D
	->PUSH F
	<<JSR XOR32
	>PUSH B
	->PUSH F
	<<JSR OR32
	>PUSH C
	->PUSH F
	<<JSR XOR32
	>GET i
	->GET i
	-->PUSH 2
	--<LSL
	-->GET i	
	--<ADD
	-->GET i
	--<ADD
	-->GET i	
	--<ADD
	-->PUSH 15
	--<AND
	<<JSR MD5ROUND
	>PUSH 1
	<ADD
	>PUSH 64
	->LT
	-<SQUEEZE
	<JNZ COMPUTEBLOCKLOOP48		
	>PUSH A
	->PUSH A0
	<<JSR ADD32
	>PUSH B
	->PUSH B0
	<<JSR ADD32
	>PUSH C
	->PUSH C0
	<<JSR ADD32
	>PUSH D
	->PUSH D0
	<<JSR ADD32	
	RETURN 0

MD5ROUND:   ;   i g  -> 
	! i g 
	>GET i
	->PUSH 2
	-<LSL
	! i g i4
	; loading value of k[i] into K
	>PUSH K
	->GET i4
	-->LOADX k
	--<SQUEEZE
	-<STORE 0
	->PUSH 1
	-<ADD
	->GET i4
	-->LOADX k+1
	--<SQUEEZE
	-<STORE 0
	->PUSH 1
	-<ADD
	->GET i4
	-->LOADX k+2
	--<SQUEEZE
	-<STORE 0
	->PUSH 1
	-<ADD
	->GET i4
	-->LOADX k+3
	--<SQUEEZE
	-<STORE 0
	<POP
	>PUSH A
	->PUSH F
	<<JSR ADD32
	>PUSH K
	->PUSH F
	<<JSR ADD32
	>PUSH M
	->GET g
	-->PUSH 2
	--<LSL
	-<ADD
	->PUSH F
	<<JSR ADD32
	>GET i
	->LOADX s
	-<SQUEEZE
	->PUSH F
	<<JSR ROL32
	>PUSH D
	->PUSH A
	<<JSR COPY32
	>PUSH C
	->PUSH D
	<<JSR COPY32
	>PUSH B
	->PUSH C
	<<JSR COPY32
	>PUSH F
	->PUSH B
	<<JSR ADD32
	RETURN 0
	
; ---------- COMPUTATION AND MOVEMENT PRIMITIVES ---------

INIT32:
; stack-in: b0 b1 b2 b3 target (ret1,ret2)
------->ADR !0
-------->GET !4
-------<<CALL COPY32
<<<<<<<RETURN

COPY32:
; stack-in: source, target (ret1,ret2)
---->GET !0
-----LOD 0
----->GET !1
-----<STO 0
----<OP POP
---->GET !0
-----LOD 1
----->GET !1
-----<STO 1
----<OP POP
---->GET !0
-----LOD 2
----->GET !1
-----<STO 2
----<OP POP
---->GET !0
-----LOD 3
----->GET !1
-----<STO 3
----<OP POP
<<<<RETURN
		
AND32:	; sourceaddr targetaddr  -> -
	! sourceaddr targetaddr
	>LOAD 0
	->GET sourceaddr
	-->LOAD 0
	--<SQUEEZE
	-<AND
	<STORE 0
	>LOAD 1
	->GET sourceaddr
	-->LOAD 1
	--<SQUEEZE
	-<AND
	<STORE 1
	>LOAD 2
	->GET sourceaddr
	-->LOAD 2
	--<SQUEEZE
	-<AND
	<STORE 2
	>LOAD 3
	->GET sourceaddr
	-->LOAD 3
	--<SQUEEZE
	-<AND
	<STORE 3
	RETURN 0

OR32:	; sourceaddr targetaddr  -> -
	! sourceaddr targetaddr
	>LOAD 0
	->GET sourceaddr
	-->LOAD 0
	--<SQUEEZE
	-<OR
	<STORE 0
	>LOAD 1
	->GET sourceaddr
	-->LOAD 1
	--<SQUEEZE
	-<OR
	<STORE 1
	>LOAD 2
	->GET sourceaddr
	-->LOAD 2
	--<SQUEEZE
	-<OR
	<STORE 2
	>LOAD 3
	->GET sourceaddr
	-->LOAD 3
	--<SQUEEZE
	-<OR
	<STORE 3
	RETURN 0

XOR32:	; sourceaddr targetaddr  -> -
	! sourceaddr targetaddr
	>LOAD 0
	->GET sourceaddr
	-->LOAD 0
	--<SQUEEZE
	-<XOR
	<STORE 0
	>LOAD 1
	->GET sourceaddr
	-->LOAD 1
	--<SQUEEZE
	-<XOR
	<STORE 1
	>LOAD 2
	->GET sourceaddr
	-->LOAD 2
	--<SQUEEZE
	-<XOR
	<STORE 2
	>LOAD 3
	->GET sourceaddr
	-->LOAD 3
	--<SQUEEZE
	-<XOR
	<STORE 3
	RETURN 0
	
; -- subroutine to add a 32-bit value to another
;  input stack:  source-address, target-address, (ret1,ret2)
;  output stack: overflow
source = 0
target = 1    
overflow = 0
ADD32:    
---->DAT 0  ; carry flag
----->GET !source   
------LOD 0  
------>GET !target  
-------LOD 0  
------<CALL FULLADD
------>GET !target  
------<STO 0 
-----<OP POP
----->GET !source
------LOD 1  
------>GET !target
-------LOD 1  
------<CALL FULLADD
------>GET !target   
------<STO 1 
-----<OP POP
----->GET !source
------LOD 2  
------>GET !target
-------LOD 2  
------<CALL FULLADD
------>GET !target   
------<STO 2 
-----<OP POP
----->GET !source
------LOD 3
------>GET !target
-------LOD 3
------<CALL FULLADD
------>GET !target  
------<STO 3 
-----<OP POP    
----<SET !overflow    ; copy carry flag to result position   
-<<<RETURN
        
; -- subroutine to do a full 8-bit add with carry 
;    (having incomming and outgoing carry and no
;     direct ALU support makes this really complex)
; input stack:  carry, x, y, (ret1,ret2)
; output stack: carry, sum
carry = 0
x = 1
y = 2
sum = 1
FULLADD:    
; detect if x+y itself would produce an overflow
----->GET !x
------>GET !y
------->DATA 255
-------<OP XOR
------<OP GT
-----<JZ NOOVERFLOW
----->GET !x   ; overflow detected - sum up x, y and carry
------>GET !y
------<OP ADD   
------>GET !carry
------<OP ADD
-----<SET !sum
----->DATA 1       ; output carry is 1
-----<SET !carry    
--<<<RETURN   
NOOVERFLOW:
----->GET !x   ; sum up x and y - no overflow can arise
------>GET !y    
------<OP ADD    
-----<SET !sum
----->GET !carry  ; check if carry is comming in
-----<JNZ INCOMMINGCARRY  
--<<<RETURN    ; when no carry comes in, no overflow can happen (and carry was already cleared)	
INCOMMINGCARRY:    
----->DATA 1
------>GET !sum
------<OP ADD      ; carry did come in, so increase the sum 	
-----<SET !sum
----->GET !sum  
-----<JNZ NOOVERFLOW2
; when after increasing, the value is 0, there was an overflow (and carry is already set)    
--<<<RETURN
NOOVERFLOW2:
----->DAT 0
-----<SET !carry   ; output carry must be cleared
--<<<RETURN

	
ROL32:      
; stack-in: distance address (ret1,ret2)
---->GET !0
----<JNZ ROL32CONTINUE
<<<<RETURN
ROL32CONTINUE:
---->GET !1
-----LOD 0
----->GET 0
------>GET !1
-------LOD 1
------<OP SHL
------>GET !1
------<STO 0
-----<OP POP
----->GET !1
------LOD 1
------>GET !1
-------LOD 2
------<OP SHL
------>GET !1
------<STO 1
-----<OP POP
----->GET !1
------LOD 2
------>GET !1
-------LOD 3
------<OP SHL
------>GET !1
------<STO 2
-----<OP POP
----->GET !1
------LOD 3
------>GET !4
------<OP SHL
------>GET !1
------<STO 3
-----<OP POP
----<OP POP
---->GET !0
----->DATA 1
-----<OP ADD
----<SET !0
----JMP ROL32


; ---------- DATA OUTPUT FUNCTIONS ------------

; input stack: (ret1,ret2)
; output stack: -
PRINTNEWLINE:
-->DATA 10
--<OUT 15
<<RETURN
	
; -- subroutine to send a readable representation
; -- of a 32-bit number to the output port 0
; input stack:  address, (ret1,ret2)
; output stack: -
address = 0
PRINT32:
--->GET !address
----LOD 3
---<CALL PRINTBYTE
--->GET !address
----LOD 2
---<CALL PRINTBYTE
--->GET !address
----LOD 1
---<CALL PRINTBYTE
--->GET !address
----LOD 0
---<CALL PRINTBYTE
<<<RETURN

; -- subroutine to send a readable representation
; -- of a single byte to the output port 0
; input stack:  byte, (ret1,ret2)
; output stack: -
byte = 0
PRINTBYTE:
--->GET !byte
---->DAT 0
----<OP SHR
---->DAT 0
----<OP SHR
---->DAT 0
----<OP SHR
---->DAT 0
----<OP SHR
---<CALL PRINTNYBBLE
--->GET !byte
---->DAT 15
----<OP AND
---<CALL PRINTNYBBLE
<<<RETURN

; -- subroutine to send a readable representation
; -- of a single nybble to the output port 15
; input stack:  nybble, (ret1,ret2)
; output stack: -
nybble = 0
PRINTNYBBLE:
--->GET !nybble
---->DATA 48  ; create code '0' - '9'
----<OP ADD
---->DATA 58
----->OPP LT
-----<SET 0
----<JNZ ONLY0TO9
---->DATA 7  ; shift code to 'A' - 'F'
----<OP ADD
ONLY0TO9:
---<OUT 15
<<<RETURN

