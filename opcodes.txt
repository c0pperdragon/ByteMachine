Overview

The CPU fetches instructions from a dedicated read-only instruction memory of
up to 64K Bytes. All instructions take exactly one clock cycle and work
on an operand stack by pushing/popping data to/from the stack and perform any
kind of operations directly with the values of the stack.

The main memory consists of 1K Bytes and is mainly used for the operand stack
and the lower 256 Bytes can also be accessed using indexed addressing.

Because the design is aimed on squeezing all instructions into a single byte
and execute them in a single clock, these instructions are very low-level 
and you often need more instructions than you would need 
for the same thing in a more complex CPU design.


Architecture

                     Clock
                       |
                       V
           RAM <->  ByteCPU  <->  Program ROM
                      |  ^ 
                      V  |
                      Ports
                       
  RAM .. 1KByte, dual ported: asynchronous read, synchronous write
  ROM .. up to 64KByte. single ported, asynchronous read
  IO ... up to 16 input and 16 output lines: individually addressable


CPU Registers

Nearly all of the program state is maintained in the main memory that is 
attached to the CPU but a few things need to be directly stored in the CPU:

   PC  .. Program counter, 16 bit. Holds address of current instruction. 
          Is directly wired to the address input of the program ROM.

   SP ... Stack pointer, 10 bit. Holds the address of the memory location that
          corresponds to the operand second-from-top of the operand stack. 
          Initialized to 255 at start-up, to avoid the indexed ram segment.
          Will normally feed the RAM read address, but sometimes other RAM 
          addresses are read instead.

   A .... Top stack element, 8 bit. The topmost element of the stack is not located in
          RAM, but directly in the CPU. This register will normally receive 
          the results of calculations. When stack pushes are performed, the
          previous value of A needs to be stored into RAM before A is 
          overwritten by a new value.

   OUT .. The values of the output pins, up to 16 bit. 
          This register directly drives the output ports.


Instructions

The general type of the instruction is defined by the higher 4 bits of the first byte
with the lower 4 bits specifying the operation in more detail.
To make the operation more clear, the effects on the registers and the memory (written as
M[..]) will be specified in sequential pseudo-code. 
Jump instructions will also effect the program counter in a different way than
just increasing it by 1 (this will be explicitly stated).


    0c  HIGH c
        Add high bits    (works as no-op when p=0)
        Uses c as high 4 bits which are then ORed to the 4 high bits of the top stack operand.
        This instruction will normally be used in conjunction with PUSH to bring a full 
        byte to the operand stack.
            A(4..7) := A(4..7) or c

    1c  PUSH c   
        Uses c as an unsigned 4-bit value and pushes a byte with this value on top of the stack
            SP := SP+1
            M[SP] := A
            A := c

    2o  OP o
        ALU operations with popping the stack
        The two top-most operands are combined according to the operation
        and replaced with the result, in effect reducing the stack size.
            A := M[SP] <o> A
            SP := SP-1

    3o  OPX o 
        ALU operations with pushing the stack
        The two top-most operands are combined according to the operation
        and the result is pushed on top of the stack, in effect increasing
        the stack size.
            TMP := M[SP] <o> A
            SP := SP+1
            M[SP] := A
            A := TMP
              
    4p  GET stackbase-p
        Fetch a value from a deeper position of the operand stack and push it on top.
            TMP := M[SP-1-p]
            SP := SP+1
            M[SP] := A
            A := TMP

    5p  SET stackbase-p
        Pop off the top value from the stack, and overwrite a deeper stack position 
        with this value.
            M[SP-1-p] := A
            A := M[SP]
            SP := SP-1

    6x  LOAD x
        Uses top operand as RAM address, adds x to it, and fetches a byte from there.
        Replace top operand with this byte.
            A := M[A+x]

    7x  STORE x
        Uses top operand as RAM address, adds the value of x to it and stores the 
        operand that is on second-from-top position to the resulting location.
        Top operand is then popped off the stack.
            TMP := M[SP]
            M[A+x] := TMP
            SP := SP-1
            A := TMP

    8X  READBIT x
        Gets the value of the input pin and pushes this value (0 or 1) on top of the
        operand stack
            SP := SP+1
            M[SP] := A
            A := INPUTPIN(x)

    9x  WRITEBIT x
        Sets the output pin x to the value of bit 0 of the top stack operand.
        Top operand is then popped off the stack.
            OUT(x) := A(0)
            A := M[SP]
            SP := SP-1
 
    Ax  JZ x
        Pops off the top element and causes a relative forward jump if the value is 0.
            TMP := A
            A := M[SP]
            SP := SP-1
            if TMP=0 then
                PC := PC + x + 2
            else
                PC := PC + 1 
            endif

    Bx  JNZ x
        Pops off the top element and causes a relative forward jump if the value is not 0.
            TMP := A
            A := M[SP]
            SP := SP-1
            if TMP<>0 then
                PC := PC + x + 2
            else
                PC := PC + 1 
            endif

    Cx  JMP x
        Pops off the top element and combines it with the value of x to form either 
        a relative forward or relative backward jump address.
            TMP := A
            A := M[SP]
            SP := SP-1
            if x(0) = 0 then   // forward
                PC := PC + TMP*8 + x(1..3)
            else               // backward
                PC := PC - TMP*8 - x(1..3)
            endif

    Dx  SUB x
        Uses the two top-most operands together with x to create the target jump address.
        These operands are then replaced with the address of the instruction right after 
        this one (to allow returning from subroutines). There is no explicit
        return operation, because SUB can be used for this purpose when x=0.                
            TMP0 := M[SP]
            TMP0(4..7) := TMP0(4..7) or x
            TMP1 := A
            TMPPC := PC+1
            M[SP] := TMPPC (0..7)
            A := TMPPC(8..15)
            PC := TMP0 + 256*TMP1

    Ex  POP x+1   
        Pops x+1 elements from the operand stack.
            SP := SP-x
            A:=M[SP]
            SP := SP-1


Arithmetic and logic operations

All arithmetic and logic operations work on two 8 bit operands to produce
an 8 bit result. The instruction set allows up to 16 possible operations, but
not all are used to keep the design slim and to allow future expandability.
In this list, X and Y will denote the first and second operand and Z the result.

    0   FIRST        Z = X
    1   SECOND       Z = Y
    2   ADD          Z = X + Y     (addition modulo 256)
    3   SUB          Z = X - Y     (subtraction modulo 256)
    4   AND          Z = X and Y   (bitwise and operation)
    5   OR           Z = X or Y    (bitwise or operation)
    6   XOR          Z = X xor Y   (bitwise xor operation)   
    7   SHL          Z = (X << 1) & Y(7)   (shift left
    8   SHR          Z = Y(7) & (X >> 1)   (shift right)
    9   LT           Z = 1, if X < Y  (0, otherwise)
    10  GT           Z = 1, if X > Y  (0, otherwise)
    11  OVFL         Z = 1, if X+Y>255 (0, otherwise)  test for overflow
