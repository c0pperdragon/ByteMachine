The Byte Machine - Instructions

The CPU fetches instructions from a dedicated read-only instruction memory with an address
width of 12 bit and data width of 8 bit (4096 instructions maximum) and operate 
on a read-write memory of 256 bytes (M).
The instruction set is optimized to allow for every instruction to fit into one
byte and to be executed in one clock. To achieve this, the instructions are quite low-level
and sometimes multiple instructions need to work together to achieve anything meaningful.
To make programming a bit easier, the assembler offers some higher-level instructions
that compile down to multiple machine instructions and are easier to read.

Most instructions work on the operand stack with new values being permanently pushed on top of 
the stack or values being popped off. In the process a stack pointer register (SP) will be adjusted 
accordingly. For the documentation of the instructions, the ram element M[SP] will be the top of the
operand stack, and M[SP-1] is the element just below it.
In addition to the operations on the stack, there are some instructions that can read/write 
arbitrary memory locations, even from the area that is occupied by the living stack (to do
something like creating references to variables on the stack as is possible in C).

The memory has a total of 256 bytes which the program can use for stack or static variables in 
any possible combination. Note that the memory will not be cleared on reset, so a program needs
to take care to set all relevant memory regions to a defined state.


The general type of the instructions is defined by the higher 4 bits of the first byte, and
the lower 4 bits specify a parameter:

    0x  EXT x
        Uses x as high 4 bits which are then ORed to the 4 high bits of M[SP].
        This instruction will normally be used in conjunction with DAT to bring a full 
        byte to the operand stack. EXT 0 can also be used as a no-operation.
            M[SP] |= (x<<4)
        
    1x  DAT x
        Uses x as an unsigned 4-bit value and pushes a byte with this value on top of the stack            
            M[SP+1] = x
            SP++
        
    2x  OP x
        ALU-Operation: Uses the two topmost-stack elements and
        computes a result according to the operation x (see section ALU below).
        The operands are then popped off the stack and replaced by the result (in effect
        reducing the stack size by 1).
            M[SP-1] = alu(x, M[SP-1], M[SP])
            SP--
            
    3x  OPP x
        ALU-Operation with pushing the stack. Works like OP, but the operands are left on
        the stack and the result is additionally pushed on top (in effect increasing the stack size).
            M[SP+1] = alu(x, M[SP-1], M[SP])
            SP++
                      
    4x  GET x
        Fetch a value from deeper down in the stack and copy it on top of the stack.
            M[SP+1] = M[SP-x]
            SP++
            
    5x  SET x
        Pop off a value from the stack, and then overwrite a stack element deeper down
        in the stack with the value
            M[SP-x-1] = M[SP]
            SP--

    6x  LOD x
        Uses the top operand as the RAM address, adds the value of x to it and fetches
        a byte from there. Overwrites the top operand with this byte.
            M[SP] = M[M[SP]+x]

    7x  STO x
        Uses top operand as RAM address, adds the value of x to it and stores the 
        second-from-top operand to the resulting location.
        Only the top operand is then popped off the stack.
            M[M[SP]+x] = M[SP-1]
            SP--
            
    8x  IN x
        Reads the current input bit pattern of input port x and puts it on top of the stack. 
            M[SP+1] = READPORT[x]
            SP++
            
    9x  OUT x
        Uses the top stack element and sets the output pins of port x to this bit pattern.
            WRITEPORT[x] = M[SP]
            SP--

    Ax  JMP x
        Pops the top stack element and combines its value with x to form a jump target address.
        Continue program at v*16 + x
            PC = M[SP]*16 + x
            SP--            
         
    Bx  JZ x
        Pops off top operand and if this is 0, the program will jump forward by x+2 instructions
        (otherwise just continue after the instruction)
            if (M[SP]==0) PC+=x+2
            else          PC++
            SP--
        
    Cx  JNZ x
        Pops off top operand and if this is not 0, the program will jump forward by x+2 instructions
        (otherwise just continue after the instruction)
            if (M[SP]!=0) PC+=x+2
            else          PC++
            SP--
    
    Dx  JSR x
        Pops the top stack element and combines its value with x to form a jump target address.
        Then the address of the instruction after this one will be pushed onto the stack
        (low byte first, then high byte). Execution continues then at the jump target.
            target = M[SP]*16 + x
            M[SP] = (PC+1)%256
            M[SP+1] = (PC+1)/256
            SP++
            PC = target

    Ex RET x
        Pops two top elements from the stack and combines them to form the jump target.
        Then x (may be 0) more elements are popped from the stack and discarded.
        Then a single 0-byte is again pushed on the stack. Program execution
        continues at the jump target.
            PC = M[SP-1] + M[SP]*256
            SP = SP-2-x
            M[SP] = 0
            SP++            
        This meaningless pushing of a single 0-byte is an artefact of the internal
        working of the CPU and its communication with the RAM and the fact that
        it is not possible to retrieve two bytes in a single clock. Normally this
        means that the caller of a subroutine needs to immediately discard this 
        unused filler byte (This will automatically be taken care of by the CALL assembler
        instruction).

    Fx ADR x
        Computes the memory address of a stack position a given distance down in the stack
        (the same element that would be fetched with the GET instruction).
        This address (not the content) will be pushed on top of the stack.
            M[SP] = SP-x
            SP++
        
ALU operations:        
A set of operations (o) are supported that take two 8-bit operands (A,B) and produce an
8-bit result. These are mainly arithmetic or logic operations or just a 
direct selection of one of the input operands.

    0    POP         result = A                          can be used with OP to perform a stack pop
    1    ADD         result = A + B                      addition modulo 256 
    2    SUB         result = A - B                      subtraction modulo 256
    3    AND         result = A & B                      bitwise and
    4    OR          result = A | B                      bitwise or 
    5    XOR         result = A ^ B                      bitwise x-or
    6    LT          result = 1 when A<B  , 0 otherwise
    7    GT          result = 1 when A>B  , 0 otherwise
    8    SHL         result = (A << 1) | (B >> 7)       shift left, take new bit from second operand
    9    SHR         result = (A >> 1) | (B << 7)       shift right, take new bit from second operand

Reset behaviour:

Upon reset (dedicated input or power-on), the program will start execution at 
instruction address 0.
The stackpointer (SP) will first be set to 255, so a subsequent DAT instruction 
(which is basically the only instruction that should be done on an empty stack) 
will fill ram address 0.
All output port registers will be set to 255 (outputs would are active low by default). 
