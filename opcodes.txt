The instruction set of the ByteMachine describes a stack machine with byte operands.
Most instructions take operands from the stack and push the result back. 
The top element of the stack is named operand(0), the element below is operand(1) and so on. 
There is only a limited space for operands on the stack (depends on the CPU parameters) 
and when the bottom-most element is pushed down, it is discarded. A subsequent pop will 
create a 0 on the bottom of the stack.
The CPU fetches instructions from a dedicated read-only instruction memory with an address
width of 12 bit (4096 bytes maximum). A dedicated 256 byte read-write memory (CPUs can
implement smaller values also) can be used to store arbitrary data.
Additionally, there is an extra space for an address stack for the return addresses of
subroutine calls. Like the operand stack, the size of this stack can be individually 
set by CPU parameters.

Machine instructions are either one-byte (for most computations) or two-byte (for jumps and ROM access).
The type of the instruction is defined by the higher 4 bits of the first byte:

    0o  Unary operations
        Uses operand(0) to perform an operation and overwrites it with the result
        00  NOP      Result is equal to the input 
        01  INC      Increases by 1
        02  DEC      Decreases by 1
        03  NEG      Computes negative value for a number considered as a signed 8-bit value
        04  LSL1     Shift left by one bit
        05  LSR1     Logical shift right by one bit
        06  ASL1     Arithmetical shift right by one bit
        07  INV      Inverts all bits
	08  NOT      1 when value=0, 0 otherwise    (boolean not)
        09  unused
        0A  unused
        0B  unused
        0C  unused
        0D  unused
        0E  unused
        0F  unused

    1o  Binary operations
        Perform an operation with the top two stack operands, pops them off the stack and pushes the
        result on top.
        10  POP     result = operand(1)
        11  ADD     result = operand(1) + operand(0)
        12  SUB     result = operand(1) - operand(0)
        13  LSL     result = operand(1) << operand(0)
        14  LSR     result = operand(1) >>> operand(0)
        15  ASR     result = operand(1) >> operand(0)
        16  AND     result = operand(1) & operand(0)
        17  OR      result = operand(1) | operand(0)
        18  XOR     result = operand(1) ^ operand(0)
        19  EQ      result = 1 when operand(1)==operand(0) , 0 otherwise
        1A  LT      result = 1 when operand(1)<operand(0)  , 0 otherwise
        1B  GT      result = 1 when operand(1)>operand(0)  , 0 otherwise
        1C  LTS     result = 1 when operand(1)<operand(0)  , 0 otherwise  (signed comparision)
        1D  GTS     result = 1 when operand(1)>operand(0)  , 0 otherwise  (signed comparision)
        1E  CARRY   result = 1 when operand(1) + operand(0) will cause an overflow on add, 0 otherwise
        1F  unused
                         
    2p  PUSH p    
        Uses p as an unsigned 4-bit value and pushes a byte with the value on top of the stack            
      
    3p  Add high bits   (has no assembler representation, but will be created automatically) 
        Uses p as high 4 bits which then replaces the 4 high bits of operand(0).
        This instruction will normally be used in conjunction with PUSH to bring a full 
        byte to the operand stack.
        
    4p  GET p
        Fetches the value of operand(p) from the operand stack and pushes it on top of the stack.
    
    5p  SET p
        Pops the top operand from the operand stack. After moving the data in the stack, it then overwrites
        operand(p) with the data.
    
    6p  LOAD p
	Uses value of operand(p) as the RAM location, fetches the byte from there and pushes it on the stack.
        
    7p  STORE p
	Uses value of operand(p) as the RAM location, pops off operand(0) and writes it to this location.
        
    8p  READ p
        Reads one byte of data from the i/o port p (read operation blocks until
	data is available) and pushes it on the stack.
    
    9p  WRITE p
        Pops the top element from the stack and writes it to the i/o port p (blocking write)
        
    An mm LOADX
        Pops off operand(0) and adds it to the instruction memory address mmn to retrieve 
        a byte of data from there. This byte will be pushed on top of the stack.
              
    Bn mm  JMP
        Continue program at the instruction memory location mmn  
         
    Cn mm  JZ
        Pops top element from the stack and if the value is 0, the program will
        continue execution at instruction memory location mmn  (otherwise just continue after the instruction)
        
    Dn mm  JNZ
        Pops top element from the stack and if the value is not 0, the program will
        continue execution at instructino memory location mmn  (otherwise just continue after the instruction)
    
    En mm JSR
        Pushes location of the instruction after the JSR onto the return address stack 
        and continues execution at instruction memory location mmn. 

    F?  RET 
	Pops top value off the address stack and continues execution there.
	
